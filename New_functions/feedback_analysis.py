#Wrapper function which decides whether the feedback is provided for python or C program

import sys
import re
import keyword
from New_functions.built_in_functions import Interaction_module
from New_functions.ift_analysis import ift_feedback, incorrect_conditional_exp
from New_functions.operator_analysis import feedback_comp_operator, feedback_arth_operator, feedback_logic_operator
from New_functions.operator_analysis import feedback_incorrect_value
from New_functions.comparing_and_tracing import compare_outputs, incorrect_return, display_location 

### GIVE THE MOST influential repair first and then next.
def check_equal(feedback):
	if "Add" in feedback or "Delete " in feedback:
		return 0
	sections = feedback.split(" to ")
	sections[0] = sections[0].split("Change ")[1]

	#at index 1 and 3 the required set of strings are present which is to be compared(Change to ==)
	if sections[0] in sections[1]:
		return 1
	return 0

def compute_cost(feedback_list, programs,rep_prog, inter,args, ins):
	compare_outputs(programs, inter,args, ins)
	### Total cost is already computed in rep_prog[0]
	# tot_cost = 0
	# for feed in feedback_list:
	# 	cost = feed.split('cost=')[1]
	# 	cost = int(re.findall(r'\d+', cost)[0])
	# 	tot_cost = tot_cost + cost

	tot_cost = rep_prog[0]
	#### HAVE to change to appropriate threshold
	if tot_cost > 15:
		print("WARNING : The cost of the repairs generated is more, recommended to analyses and make your program better to have less cost repairs")
		print("As high cost repairs are usually not recommended to consider for debugging")
		print("If you still prefer to look at repairs, press any key, to exit press 0")
		reply = input()
		if reply == '0':
			sys.exit("*** Happy Coding!!! ***\n")

def feedback_channelizer(clara_feedback, feed_no, programs,rep_prog, inter, inputs, arguements, lang):
	if(check_equal(clara_feedback)):   #function to check if feedback generated by clara is with no change suggestions 
		print("Unnecessary feedback!!!")
		return
	else:
		considered = 0
		### Display the location in program where the bug is
		print("Encountered error number :", feed_no)
		print("----------------------------------------------------------------\n")
		location = display_location(clara_feedback)
		print("** The location in your program where the bug detected is :")
		print(location, "**\n")
		print("--------------------------------------------------------------------------\n")
		#print("--------",clara_feedback)
		#When an expression is to be deleted from incorrect program
		if "Add" in clara_feedback or "Delete " in clara_feedback:
			considered = 1
			print("Clara is suggesting either to remove or add an expression in your code, this would mean that cost of repair is more")
			print("It is recommended that you consider debugging on your own first")
			print("If not then press 1 to look at repair generated or press 0 to exit")
			reply = input()
			if reply == '1':
				print(clara_feedback,"\n")
				print("****************************************************\n")
				return 
			elif reply == '0':
				sys.exit("*** Happy Coding!!! ***\n")
			else:
				return 
		# Getting the line number 
		if 'line' in clara_feedback:
			clara_split = clara_feedback.split('line ')
		elif 'at' in clara_feedback:
			clara_split = clara_feedback.split('at ')

		line_num = 0
		if (clara_split[1].split(' ')[0]).isdigit():
			line_num = clara_split[1].split(' ')[0]

		# For python language specific
		if(lang == 'py'):
			python_builtins = ['range', 'sum','reduced', 'slice','next', 'list','set', 'dict']
			keywords = keyword.kwlist

			bltins_error = [] #To store the builtins where the user has gone wrong
			for blt in python_builtins:
				if (blt+"(") in clara_feedback:
					bltins_error.append(blt)

			if bltins_error != []:
				considered = 1
				print("Looks like you have made a logical mistake in usage of one of the builtin method or function",end = " ")
				if line_num:
					print("at line number : ",line_num)
				print("Would you like to know name of builtin?")
				print("yes/no\n")
				reply = input()
				if(reply == 'no' or reply == 'No' or reply == 'NO'):
					sys.exit("Nice!!! You don't want to giveup so easily. Happy coding!")
				elif(reply == 'yes' or reply == 'Yes' or reply == 'YES'):
					Interaction_module(clara_feedback,bltins_error[0],arguements)
				return 

			#check for if it is a keyword
			'''
			keyword_error = []
			for key in keyword.kwlist:
				if key in clara_feedback:
					keyword_error.append(key)

			if keyword_error != []:
				print("Looks there are one or more keywords, where you have used it illogically with respect to given problem statement")
				print("This is at line number :",line_num)
				print("Do you ")
			'''
		if 'ite(' in clara_feedback:
			print("Looks like you have implemented if-then-else illogically with respect to the given problem statement.", end = " ")
			# if line_num:
			# 	print("This wrong implementation is at line number : ", line_num)
			print("It is recommended that you read through the problem statement again, before proceeding to debug")
			#implementation of effective feedback for ift
			print("Or you can choose to be given with a detailed explanation by pressing 1, orelse press 0 to exit\n")
			reply_1 = int(input())
			if(reply_1 == 0):
				sys.exit("*** Happy Coding!!! ***\n")
			else:
				ift_feedback(clara_feedback, inputs, arguements)
			return


		#incorrect conditional statements($cond)
		if '$cond' in clara_feedback:
			incorrect_conditional_exp(clara_feedback, arguements, inputs)

		#check for incorrect return value
		if ('return' in clara_feedback) or ('$ret' in clara_feedback):
			incorrect_return(clara_feedback,programs, rep_prog, inter, arguements, inputs)
			print("Press 1 to continue with possible any further related repairs, else press 0 to exit")
			reply = int(input())
			if reply == 0:
				sys.exit("*** Happy Coding!!! ***\n")

		#incorrect use of operators	
		if not(considered):
			# arithmetic_operators = ['+','-','*','/','%']
			# comparison_operators = ['==','!=','<','<=','>','>=']
			arithmetic_operators_dict = {'+':'Addition', '-':'Subtraction', '*':'Multiplication', 
									'/' : 'Division', '%' : 'Modulus(returns remainder)'}
			comparison_operators_dict = {'==' : 'equal to', '!=' : 'not equal to', '<':'less than',
									'<=':'less than or equal to', '>':'greater than', '>=':'greater than or equal to'}
			logical_operators = [' and ', ' or ', ' && ', ' || ', ' & ', ' | ']

			segments = clara_feedback.split(" to ")
			segments[0] = segments[0].split("Change ")[1]
			# loc = display_location(clara_feedback)
			segments[1] = segments[1].split(location)[0]
			arithmetic_operators = list(arithmetic_operators_dict.keys())
			comparison_operators = list(comparison_operators_dict.keys())
			for op in arithmetic_operators+comparison_operators+logical_operators:
				if (op in segments[0] and op not in segments[1]) or (op not in segments[0] and op in segments[1]): #This is feasible for single operator error
					if op in arithmetic_operators:
						operator = arithmetic_operators_dict[op]+' ('+op+')'
						feedback_arth_operator(segments,operator,line_num,clara_feedback, inputs, arguements)
						return 
					elif op in comparison_operators:
						operator = comparison_operators_dict[op]+' ('+op+')'
						feedback_comp_operator(segments,operator,line_num, clara_feedback, inputs, arguements)
						return
					elif op in logical_operators:
						feedback_logic_operator(segments, op, line_num, clara_feedback, inputs, arguements) 
						return

			#incorrect use of values
			# using re.findall() 
			# getting numbers from string  
			num1 = re.findall(r'\d+', segments[0]) 
			num2 = re.findall(r'\d+', segments[1]) 
			if num1 != [] and num2 != []: 
				if(num1[0] != num2[0]):
					feedback_incorrect_value(num1[0], num2[0], line_num, clara_feedback, inputs, arguements)
					return
			elif num1 != [] or num2 != []:
				print("There might be an incorrect initialization", end = " ")
				if line_num:
					print("at line number :",line_num)
				print("It is recommended that you dry run through code look for right initialization")
				print("Repair to this has been generated, press 1 to see repair or 0 to exit")
				reply2 = int(input())
				if(reply2 == 1):
					print(clara_feedback, "\n")
					print("***************************************************\n")
				return 

		print("No further explanation specific to your code could be generated")
		print("Press 1 to just look at repairs directly, else press 0 to exit")
		reply = int(input())
		if reply == 1:
			print(clara_feedback,"\n")
			print("****************************************************\n")
		elif reply == 0:
			sys.exit("*** Happy Coding!!! ***\n")
		#FOR most of feedbacks can compare between incorrect and correction expression given in feedback 





