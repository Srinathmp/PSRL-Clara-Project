import re
import keyword
from New_functions.built_in_functions import Interaction_module
from New_functions.ift_analysis import ift_feedback, incorrect_conditional_exp
from New_functions.operator_analysis import feedback_comp_operator, feedback_arth_operator, feedback_logic_operator
from New_functions.operator_analysis import feedback_incorrect_value
from New_functions.comparing_and_tracing import compare_outputs, incorrect_return, display_location
from New_functions.simp_feed import feed_main 
from Documentation.python_doc_testing import for_loop_func
### GIVE THE MOST influential repair first and then next.
'''
def get_key(index_dict, val):
	l = []
	for key, value in index_dict.items():
		if val == value:
			l.append(key)

	return l

def sort_repair_cost(feedback_list):
	# provide the least cost repair first 
	index_dict = dict()
	sorted_list = []
	for i in range(len(feedback_list)):
		cost = feedback_list[i].split('cost=')[1]
		cost = int(re.findall(r'\d+', cost)[0])
		index_dict[i] = cost

	# Will hold unique cost list
	cost_sorted = list(set(sorted(index_dict.values())))
	# print(cost_sorted)
	for cost in cost_sorted:
		repair_list = get_key(index_dict,cost)
		# print(repair_list)
		for index in repair_list:
			sorted_list.append(feedback_list[index])

	# Sorted list holds the sorted repairs based on cost
	return sorted_list
'''
def check_equal(feedback):
	if "Add" in feedback or "Delete " in feedback:
		return 0
	sections = feedback.split(" to ")
	sections[0] = sections[0].split("Change ")[1]

	#at index 1 and 3 the required set of strings are present which is to be compared(Change to ==)
	if sections[0] in sections[1]:
		return 1
	return 0

def compute_cost(feedback_list, programs,rep_prog, inter,args, ins):
	compare_outputs(programs, inter,args, ins)
	### Total cost is already computed in rep_prog[0]
	# tot_cost = 0
	# for feed in feedback_list:
	# 	cost = feed.split('cost=')[1]
	# 	cost = int(re.findall(r'\d+', cost)[0])
	# 	tot_cost = tot_cost + cost

	tot_cost = rep_prog[0]
	#### HAVE to change to appropriate threshold
	if tot_cost > 15:
		print("WARNING : The cost of the repairs generated is more, recommended to analyses and make your program better to have less cost repairs")
		print("As high cost repairs are usually not recommended to consider for debugging")
		print("If you still prefer to look at repairs, press any key, to exit press 0")
		reply = input()
		if reply == '0':
			print("*** Happy Coding!!! ***\n")
			return 0

# Function to analysis the type of feedback 
def feedback_channelizer(clara_feedback, feed_no, programs,rep_prog, inter, inputs, arguements, lang):
	try:
		if inputs != None:
			trace_incorrect_prog = inter.run(programs[-1], None,inputs[0], arguements)
		elif arguements != None:
			trace_incorrect_prog = inter.run(programs[-1], None,  arguements[0], inputs)

		cleaned_feedback = feed_main(clara_feedback, trace_incorrect_prog)
		#print(cleaned_feedback)
	except Exception as err:
		print('Exception arose is(cl) :', err)
		cleaned_feedback = clara_feedback
		#print(cleaned_feedback)
	try:
		if(check_equal(clara_feedback)):   #function to check if feedback generated by clara is with no change suggestions 
			print("Unnecessary feedback!!!")
			return
		else:
			considered = 0
			### Display the location in program where the bug is
			print("Encountered error number :", feed_no)
			print("----------------------------------------------------------------\n")
			location = display_location(clara_feedback)
			if location != None:	
				print("** The location in your program where the bug detected is :")
				print(location, "**\n")
				print("--------------------------------------------------------------------------\n")
			#print("--------",clara_feedback)
			#When an expression is to be deleted from incorrect program
			if "Add" in clara_feedback or "Delete " in clara_feedback:
				considered = 1
				print("Clara is suggesting either to remove or add an expression in your code, this would mean that cost of repair is more")
				print("It is recommended that you consider debugging on your own first")
				print("If not then press 1 to look at repair generated or press 0 to exit")
				reply = input()
				if reply == '1':
					print(cleaned_feedback,"\n")
					print("****************************************************\n")
					return 
				elif reply == '0':
					print("*** Happy Coding!!! ***\n")
					return 0
				else:
					return 

			# Getting the line number 
			#### Will remove line number as not needed
			# clara_split = 0
			# if 'line' in clara_feedback:
			# 	clara_split = clara_feedback.split('line ')
			# elif 'at' in clara_feedback:
			# 	clara_split = clara_feedback.split('at ')

			# line_num = 0
			# if (clara_split[1].split(' ')[0]).isdigit():
			# 	line_num = clara_split[1].split(' ')[0]

			# For python language specific
			if(lang == 'py'):
				python_builtins = [
        					'input', 'float', 'int', 'bool', 'str', 'list', 'dict',
        					'set', 'tuple', 'round', 'pow', 'sum', 'range', 'xrange', 'len',
        					'reversed', 'enumerate', 'abs', 'max', 'min', 'type', 'zip', 'map',
        					'isinstance']
				keywords = keyword.kwlist

				bltins_error = [] #To store the builtins where the user has gone wrong
				for blt in python_builtins:
					if (blt+"(") in clara_feedback:
						bltins_error.append(blt)

				if ' for loop ' in clara_feedback:
					print("There is an incorrect iterated expression used in for loop\n")
					print("To know about for loop press 1, else press any key to continue :\n")
					choice = input()
					if choice == '1':
						print("\n---------------------------------------------------------------------------------------------------\n")
						for_loop_func()
						print("\n---------------------------------------------------------------------------------------------------\n")
				if bltins_error != []:
					considered = 1
					print("Looks like the incorrect code is due to one of the builtin method or function")
					print("Would you like to know name of builtin?")
					print("yes/no\n")
					reply = input()
					if(reply == 'no' or reply == 'No' or reply == 'NO'):
						print("Nice!!! You don't want to giveup so easily. Happy coding!")
						return 0
					elif(reply == 'yes' or reply == 'Yes' or reply == 'YES'):
						for blt in bltins_error:
							status = Interaction_module(clara_feedback,cleaned_feedback,blt,arguements)
							if status == 0:
								return 0
					return 


				#check for if it is a keyword
				'''
				keyword_error = []
				for key in keyword.kwlist:
					if key in clara_feedback:
						keyword_error.append(key)

				if keyword_error != []:
					print("Looks there are one or more keywords, where you have used it illogically with respect to given problem statement")
					print("This is at line number :",line_num)
					print("Do you ")
				'''
			segments = clara_feedback.split(" to ")
			segments[0] = segments[0].split("Change ")[1]
			# loc = display_location(clara_feedback)
			segments[1] = segments[1].split(location)[0]

			if 'ite(' in clara_feedback:
				print("Looks like you have implemented if-then-else illogically with respect to the given problem statement.")
				print("It is recommended that you read through the problem statement again, before proceeding to debug")
				#implementation of effective feedback for ift
				print("Press 1 for exhaustive feedback phase, orelse press 0 to exit\n")
				reply_1 = input()
				if(reply_1 == '0'):
					print("*** Happy Coding!!! ***\n")
					return 0
				else:
					ift_feedback(cleaned_feedback,cleaned_feedback, inputs, arguements, lang)
				return


			#incorrect conditional statements($cond)
			if '$cond' in clara_feedback:
				status = incorrect_conditional_exp(clara_feedback, arguements, inputs)
				if status == 0:
					return 0

			#check for incorrect return value
			if ('return' in clara_feedback) or ('$ret' in clara_feedback):
				incorrect_return(clara_feedback,cleaned_feedback,programs, rep_prog, inter, arguements, inputs)
				if ' if ' in segments[0] or ' if ' in segments[1]:
					print("Since there was 'if' statements involved, press 1 to read about it, else any key to continue")
					ans = input()
					if ans == '1':
						status = ift_feedback(clara_feedback, cleaned_feedback, inputs, arguements, lang)
						if status == 0:
							return 0
				print("Press 1 to continue with possible any further related repairs, else press 0 to exit")
				reply = int(input())
				if reply == 0:
					print("*** Happy Coding!!! ***\n")
					return 0

			#incorrect use of operators	
			if not(considered):
				# arithmetic_operators = ['+','-','*','/','%']
				# comparison_operators = ['==','!=','<','<=','>','>=']
				arithmetic_operators_dict = {'+':'Addition', '-':'Subtraction', '*':'Multiplication', 
										'/' : 'Division', '%' : 'Modulus(returns remainder)'}
				comparison_operators_dict = {'==' : 'equal to', '!=' : 'not equal to', '<':'less than',
										'<=':'less than or equal to', '>':'greater than', '>=':'greater than or equal to'}
				logical_operators = [' and ', ' or ', ' && ', ' || ', ' & ', ' | ']

				arithmetic_operators = list(arithmetic_operators_dict.keys())
				comparison_operators = list(comparison_operators_dict.keys())
				for op in arithmetic_operators+comparison_operators+logical_operators:
					if (op in segments[0] and op not in segments[1]) or (op not in segments[0] and op in segments[1]): #This is feasible for single operator error
						if op in arithmetic_operators:
							operator = arithmetic_operators_dict[op]+' ('+op+')'
							return feedback_arth_operator(segments,operator,clara_feedback,cleaned_feedback, inputs, arguements) 
						elif op in comparison_operators:
							operator = comparison_operators_dict[op]+' ('+op+')'
							return feedback_comp_operator(segments,operator,clara_feedback,cleaned_feedback, inputs, arguements)
						elif op in logical_operators:
							return feedback_logic_operator(segments, op,clara_feedback, cleaned_feedback, inputs, arguements) 

				#incorrect use of values
				# using re.findall() 
				# getting numbers from string  
				num1 = re.findall(r'\d+', segments[0]) 
				num2 = re.findall(r'\d+', segments[1]) 
				if num1 != [] and num2 != []: 
					if(num1[0] != num2[0]):
						return feedback_incorrect_value(num1[0], num2[0], clara_feedback,cleaned_feedback, inputs, arguements)
				elif num1 != [] or num2 != []:
					print("There might be an incorrect initialization.")
					print("It is recommended that you dry run through code look for right initialization")
					print("Repair to this has been generated, press 1 to see repair or 0 to exit")
					reply2 = int(input())
					if(reply2 == 1):
						print(cleaned_feedback, "\n")
						print("***************************************************\n")
					return 

			print("No further explanation specific to error number :=",feed_no,",could be generated")
			print("Press 1 to just look at repairs directly, else press 0 to exit")
			reply = input()
			if reply == '1':
				print(cleaned_feedback,"\n")
				print("****************************************************\n")
			else:
				print("*** Happy Coding!!! ***\n")
				return 0
			#FOR most of feedbacks can compare between incorrect and correction expression given in feedback 
	except Exception as err:
		print("Exception arose is :",err)
		print("Detailed explanation couldn't be generated, press 1 to look at repairs directly, else press 0 to exit")
		choice = input()
		if choice == '1':
			print(cleaned_feedback,"\n")
			print("****************************************************\n")
		else:
			print("*** Happy Coding!!! ***\n")
			return 0



